function [s, linenos, tmpvarinrest] = getVariableCodelineRangefromMFile(m_filename)
%GETVARIABLECODELINERANGEFROMMFILE validate the syntax of MATLAB file for matlab.io.saveVariablesToScript.
%   GETVARIABLECODELINERANGEFROMMFILE returns a struct s that contains the
%   name of variables that can be created from the MATLAB file as struct field.
%   The value of field indicates the contiguous MATLAB Code range of corresponding
%   variable in the MATLAB file, and whether the variable is created from MATLAB Code
%   or from the associated MAT-File, as well as whether any temporary
%   variables are used for this variable.
%
%   The MATLAB file must have no errors from M-Lint.
%   The order of field names of s is same as the order that these variables
%   are re-created from MATLAB file.
%   The value of each field is a numeric array that contains 4 elements
%   [l1, l2, m, t]. l1, l2 is the starting and ending MATLAB Code lines in the
%   MATLAB file for the corresponding variable. l1 must be no larger than l2,
%   and [l1, l2] cannot be overlapping across any two of variables.  
%   The value of m is either 1 or 0. 1 indicates the variable is created
%   from MATLAB Code, 0 means the variable is created from MAT-Format.
%   The value of t is either 1 or 0. 1 indicates the temporary variable is
%   used for this variable, 0 means none is used.
%
%   linenos contains 5 line numbers for the following lines: 
%   1. The first line of header section.
%   2. The line of load saveVarsMat statement
%   3. The first line of Code or the first non-blank line after header
%   section when no load statement existed in MATLAB file
%   4. The last line before clear saveVarsTmp statement
%   5. The last line of Code
%
%   tmpvarinrest indicates if any temporary variable is used in the code
%   lines not captured in struct s
%
%
%   See also matlab.io.saveVariablesToScript, MTREE

%   Copyright 1984-2013 The MathWorks, Inc.


try  
    % check MATLAB file m_filename exist (Do not check MATLABPATH)
    y = ls(m_filename);
    if isempty(y) % on window 'ls' returns empty string ''
        DAStudio.error('MATLAB:savevars:SaveVarsMFileOpenW', m_filename);
    end
catch e
    DAStudio.error('MATLAB:savevars:SaveVarsMFileOpenW', m_filename);
end

try
    % construct mtree without comment node for MATLAB file
    T = mtree(m_filename, '-file', '-com');
    if T.isempty
        DAStudio.error('MATLAB:savevars:SaveVarsEmptyOrLargeFile', m_filename);
    end

    % check MATLAB file contains only expression, function call statements, no
    % any control flow. 
    % check each single code line of MATLAB file is not shared by multiple
    % statements.
    % return code line range for each statement and header line, first code
    % line(first non-empty line after header), and last code line
    [statementCodelineRanges, hline, codeSline, codeEline] = getCodeLineRangeforHeaderAndEachStatement(m_filename, T);

    % get variable and function ID nodes from mtree
    % ids is a struct with fields: node#, ID name, code line no, isvar
    ids = getVarandFncIDNodes(T);

    % return a struct var specifies codeline range and mode (M or MAT) for
    % each unique variable
    [s, ldline, contentEline, tmpvarinrest] = getCodeLineRangeforEachVariable(m_filename, T, statementCodelineRanges, ids, hline, codeEline);
  
    linenos(1) = hline;     % header start lineno
    linenos(2) = ldline;    % matvars = load( ) lineno
    linenos(3) = codeSline; % first line of code
    linenos(4) = contentEline; % last line of code before clear('matvars');
    linenos(5) = codeEline;    % last line of code
    assert(codeSline<=codeEline && contentEline<=codeEline);
    if ( hline > 0 )
        assert(hline<codeSline);
    end
    if ( ldline > 0 )
        assert(ldline==codeSline);
    end
%disp(s);
%disp(linenos);
    % check code line interleave across variables
    checkCodeLineOverlappingAmongVariables(m_filename, s);

catch e
    throw(e);
end 

% ----------------------------
% SUB-FUNCTIONS
% ----------------------------
 
% get header start lineno, first code lineno, last code lineno, make sure
% header is in front of first code line.
% verify each statement is valid and not sharing any single line.
% get line range for each statement.
function [r, headerLineno, codeSline, codeELine] = getCodeLineRangeforHeaderAndEachStatement(m_filename, T)

if ~isempty(mtfind(T, 'Kind', 'ERR'))
    DAStudio.error('MATLAB:savevars:SaveVarsInvalidMFile', m_filename);
end

% The following header string must be identical to one
% defined in src/savevars/SaveVarsFunctions.cpp

HEADERSIGNATURESTR = '%  Generated by MATLAB on ';
HEADERSIGNATURESTRLEN = length(HEADERSIGNATURESTR);
HEADERHEIGHT = 4;

% tree is non-empty
nds = root(T);
nds = nds.list; % nodes for all the statements in MATLAB file
nds_nos = reshape(nds.indices, length(nds.indices), 1);
nds_linenos = nds.lineno;

% nodes for valid statements
expr_nodes = mtfind(nds, 'Kind', 'EXPR'); % node type 1
dcall_nodes = mtfind(nds, 'Kind', 'DCALL'); % node type 2
comm_nodes = mtfind(nds, 'Kind', 'COMMENT'); % node type 3
blkcom_nodes = mtfind(nds, 'Kind', 'BLKCOM'); % node type 4

expr_nos = expr_nodes.indices;
dcall_nos = dcall_nodes.indices;
comm_nos = comm_nodes.indices;
blkcom_nos = blkcom_nodes.indices;

items = zeros(length(expr_nos)+length(dcall_nos)+length(comm_nos)+length(blkcom_nos),4);

nd_num1 = 1;
nd_num2 = length(expr_nos);
if nd_num2 > 0
    expr_slineno = pos2lc(T, lefttreepos(expr_nodes));
    expr_elineno = pos2lc(T, righttreepos(expr_nodes));
    items(1:nd_num2, 1) = reshape(expr_nos, nd_num2, 1);
    items(1:nd_num2, 2) = 1;
    items(1:nd_num2, 3) = expr_slineno;
    items(1:nd_num2, 4) = expr_elineno;
    nd_num1 = nd_num1+nd_num2;
end

nd_num2 = length(dcall_nos);
if nd_num2 > 0
    dcall_slineno = pos2lc(T, lefttreepos(dcall_nodes));
    dcall_elineno = pos2lc(T, righttreepos(dcall_nodes));
    items(nd_num1:nd_num1+nd_num2-1, 1) = reshape(dcall_nos, nd_num2, 1);
    items(nd_num1:nd_num1+nd_num2-1, 2) = 2;
    items(nd_num1:nd_num1+nd_num2-1, 3) = dcall_slineno;
    items(nd_num1:nd_num1+nd_num2-1, 4) = dcall_elineno;
    nd_num1 = nd_num1+nd_num2;
end

nd_num2 = length(comm_nos);
if nd_num2 > 0
    comm_linenos = comm_nodes.lineno; % comment line is always a single line
    items(nd_num1:nd_num1+nd_num2-1, 1) = reshape(comm_nos, nd_num2, 1);
    items(nd_num1:nd_num1+nd_num2-1, 2) = 3;
    items(nd_num1:nd_num1+nd_num2-1, 3) = comm_linenos;
    items(nd_num1:nd_num1+nd_num2-1, 4) = comm_linenos;
    nd_num1 = nd_num1+nd_num2;
end

nd_num2 = length(blkcom_nos);
if nd_num2 > 0
    blkcom_slineno = pos2lc(T, lefttreepos(blkcom_nodes));
    blkcom_elineno = pos2lc(T, righttreepos(blkcom_nodes));
    items(nd_num1:nd_num1+nd_num2-1, 1) = reshape(blkcom_nos, nd_num2, 1);
    items(nd_num1:nd_num1+nd_num2-1, 2) = 4;
    items(nd_num1:nd_num1+nd_num2-1, 3) = blkcom_slineno;
    items(nd_num1:nd_num1+nd_num2-1, 4) = blkcom_elineno;
end

num_nds = nd_num1+nd_num2-1;

items = sortrows(items);

% check for invalid statements
[~, idx] = setdiff(nds_nos, items(:,1));
if ~isempty(idx)
    badLinenoStr = num2str(nds_linenos(idx(1)));
    for k=2:length(idx)
        badLinenoStr = strcat(badLinenoStr, [', ', num2str(nds_linenos(idx(k)))]);
    end
    DAStudio.error('MATLAB:savevars:SaveVarsNonExpressionStatement', m_filename, ...
        badLinenoStr);
end

headerLineno = 0;
codeSline = 0;
codeELine = 0;
anyCode = false;

% At this point nodes can only be EXPR, DCALL, COMMENT, BLKCOM
% find header line, first code line and last code line
k = 1; % index for valid statements
while ( 1 )

    node_no = items(k,1);
    node_type = items(k,2);
    sline_no = items(k,3);
    eline_no = items(k,4);
    
    if node_type == 3 || node_type == 4 % COMMENT or BLKCOM
        if headerLineno == 0 
            if node_type == 3 % COMMENT
                % check if it is the generated Header line
                nd = T.setIX(node_no);
                if ( strncmp(nd.string, HEADERSIGNATURESTR, HEADERSIGNATURESTRLEN) ...
                    && verifyHeaderIntegrity(nd) )
                    headerLineno = sline_no-1;
                    assert(headerLineno>0);
                    k = k+HEADERHEIGHT-2; % skip next two lines
                end
            end
        else % header was found
            if codeSline == 0
                codeSline = sline_no;
            end
        end
    else
        anyCode = true;
        if codeSline == 0   % EXPR or DCALL
            codeSline = sline_no;
        end
    end
    
    if ( k == num_nds ) % last node
        codeELine = eline_no;
        break;
    end
    
    k = k+1;
      
end

if ~anyCode
    DAStudio.error('MATLAB:savevars:SaveVarsEmptyCodeLine', m_filename);
end

if headerLineno > codeSline
    DAStudio.error('MATLAB:savevars:SaveVarsHeaderInFront', headerLineno, m_filename, codeSline);
end


nds = T.setIX([expr_nodes.indices, dcall_nodes.indices]); % union of two sets of nodes
sLines = pos2lc(T, lefttreepos(nds));
eLines = pos2lc(T, righttreepos(nds));

num = length(sLines);
badCodelines = '';
lastbadline = 0;
% check any code line is shared
r = zeros(num, 2);
isfirst = true;
for k=1:num
    this_endline = eLines(k);
    assert(sLines(k) <= this_endline);
    r(k,1) = sLines(k);
    r(k,2) = eLines(k);
    if ( k < num && this_endline >= sLines(k+1) && this_endline ~= lastbadline )
        if ( isfirst )
            badCodelines = num2str(this_endline);
            isfirst = false;
        else
            badCodelines = strcat(badCodelines, [', ', num2str(this_endline)]);
        end
        lastbadline = this_endline;
    end
end
if ~isempty(badCodelines)
    DAStudio.error('MATLAB:savevars:SaveVarsSharedCodeLine', ...
    badCodelines, m_filename);
end

% verify if the header is the same as supposed to be
function r = verifyHeaderIntegrity(line2Node)
r = true;
SAVEVARSSEPERATOR = '% -------------------------------------------------------------------';
MATLABVERSIONLINE = '%  MATLAB version: ';

line1Node = line2Node.Parent;
line3Node = line2Node.Next;
if ( line1Node.isnull || line3Node.isnull || line1Node.lineno<=0 || ...
     line2Node.lineno ~= line1Node.lineno+1 || line3Node.lineno ~= line2Node.lineno+1)
    r = false;
else
    line4Node = line3Node.Next;
    if ( line4Node.isnull || line4Node.lineno ~= line3Node.lineno+1 )
        r = false;
    else
        if ~line1Node.iskind('COMMENT') || ...
            ~isequal(line1Node.string, SAVEVARSSEPERATOR)
            r = false;
        elseif ~line3Node.iskind('COMMENT') || ...
            ~strncmp(line3Node.string, MATLABVERSIONLINE, length(MATLABVERSIONLINE)) || ...
                ~line4Node.iskind('COMMENT') || ~isequal(line4Node.string, SAVEVARSSEPERATOR)
            r = false;
        end
    end
end

% get nodes for variables and functions
% ids is a struct array with fields: node#, ID name of the node, code
% lineno of the node, isvar indicates if it is a variable or function 
function ids = getVarandFncIDNodes(T)
% get variable nodes and their corresponding names
varnodes = mtfind(T, 'Isvar',true);
% node number of these var ID nodes
varnode_nums = varnodes.indices;
% var ID names
varnames = strings(varnodes);
% line number of these vars in MATLAB file, which must increase monotonously
varline_nums = lineno(varnodes);

fncnodes = mtfind(T, 'Isfun',true);
fncnode_nums = fncnodes.indices;
fncnames = strings(fncnodes);
fncline_nums = lineno(fncnodes);

% combine these two sets of nodes in order
k=1; q=1; p=1;
ids = struct('node_no', {}, 'name', {}, 'line_no', {}, 'isvar', {});
num_varnodes = length(varnode_nums);
num_fncnodes = length(fncnode_nums);
while(p<= num_varnodes + num_fncnodes )

    if ( q > num_fncnodes || ...
        k <= num_varnodes && varnode_nums(k) < fncnode_nums(q) )
        ids(p).node_no = varnode_nums(k);
        ids(p).name = varnames{k};
        ids(p).line_no = varline_nums(k);
        ids(p).isvar = 1; % var ID
        k = k+1;
    else
        ids(p).node_no = fncnode_nums(q);
        ids(p).name = fncnames{q};
        ids(p).line_no = fncline_nums(q);
        ids(p).isvar = -1; % function ID
        q = q+1;
    end
    p = p+1;
end

% get load statement for saveVarsMat and code line range for each variable
% verify header and load statement stay together
% verify the syntax of load statement, saveVarsMat usage, clear statement
% detect if there is clear statement at the end
% detect if saveVatsTmp is used for each statement
function [s, matline, eline, use_tmpvar] = getCodeLineRangeforEachVariable(m_filename, T, R, ids, hline, eline)

s = struct;

TMPVARNAME = 'saveVarsTmp';
MATVARNAME = 'saveVarsMat';
HEADERHEIGHT = 4;

% var_set: cell array for variables/function within each statement
% each cell has type(var or func) and a list of variable or function names
% function name appears only once if no variable comes before
num_statements = size(R,1);
assert(num_statements>0);
var_set = cell(num_statements,2);
tmpvar_flags = zeros(num_statements,1);

k=1; % index for variables
q=1; % index for statements
isMatvarsLoaded = false;
matline = 0;
while(k<=length(ids))
    node_num = ids(k).node_no;
    varname = ids(k).name;
    type = ids(k).isvar;
    line_no = ids(k).line_no;
    % variable must oblong to this statement or later statements
    assert(line_no>=R(q,1));

    if ( line_no <= R(q,2) )
        if isempty(var_set{q,1}) 
            % first ID(var or func) for this statement
            if ( ids(k).isvar >= 0 )
                % a var
                if strcmp(varname, MATVARNAME)
                    % check if matvars were assigned values more than once in
                    % MATLAB file
                    [~, namestr] = fileparts(m_filename); 
                    matloadStr = sprintf('%s = load(''%s'');', MATVARNAME, [namestr, '.mat']);
                    if ( isMatvarsLoaded )
                        DAStudio.error('MATLAB:savevars:SaveVarsMATVarsLoadAgain', ...
                            line_no, m_filename, MATVARNAME);
                    elseif ( ~verifyMatvarStatement(geteq(T.setIX(node_num)), matloadStr) )
                        % matvars load syntax error
                        DAStudio.error('MATLAB:savevars:SaveVarsInvalidLoadSyntax', ...
                            line_no, m_filename, MATVARNAME, [m_filename, 'at'], matloadStr);
                    elseif q ~= 1
                        % matvars load does not come first
                        DAStudio.error('MATLAB:savevars:SaveVarsLoadNotAtFirst', ...
                            line_no, m_filename, MATVARNAME);
                    else
                        isMatvarsLoaded = true;
                        matline = line_no;
                    end
                elseif strcmp(varname, TMPVARNAME)
                    % a tmp var 
                    tmpvar_flags(q) = 1; 
                end
            elseif strcmp(varname, 'clear')
                % function clear

                this_node = T.setIX(node_num);
                flag = isFncClearSyntaxCorrect(this_node, TMPVARNAME);
                if flag < 0
                    DAStudio.error('MATLAB:savevars:SaveVarsClearFuncSyntax', ...
                             line_no, m_filename, TMPVARNAME, varname, TMPVARNAME);
                elseif flag > 0
                    type = -2; % indicate this is clear tmpvars;
                else
                    % verify clear matvars; is last statement
                    flag = isFncClearSyntaxCorrect(this_node, MATVARNAME);
                    if flag < 0
                        DAStudio.error('MATLAB:savevars:SaveVarsClearFuncSyntax', ...
                             line_no, m_filename, MATVARNAME, varname, MATVARNAME); 
                    elseif flag > 0
                        % statement clear matvars;
                        if  R(q,2) ~= eline 
                            % not last line of code
                            DAStudio.error('MATLAB:savevars:SaveVarsClearNotAtLast', ...
                             line_no, m_filename, MATVARNAME, varname, MATVARNAME);
                        else
                            % endline excludes clear('matvars');
                             eline = max(R(q,1)-1,0);
                        end
                    end
                end  
            end
            var_set{q,1} = type;
            var_set{q,2}{1} = varname;
        elseif (ids(k).isvar >= 0 )
            % other vars in the statement
            if strcmp(varname, TMPVARNAME)
                if var_set{q,1} ~= -2
                    % a tmp var not with function clear 
                    tmpvar_flags(q) = 1;
                end
            else
                % a variable which is not a tmpvars
                var_set{q,2}{end+1} = varname;

                if strcmp(varname, MATVARNAME)
                    % verify it matches syntax pattern a = matvars.a;
                    stmt = [var_set{q,2}{1}, ' = ', MATVARNAME, '.', var_set{q,2}{1},';'];
                    if ~isMatvarSyntaxCorrect(T.setIX(node_num), stmt)
                       % e.g. 'a = matvars.a1'
                        DAStudio.error('MATLAB:savevars:SaveVarsMATVariableSyntax', ...
                             line_no, m_filename, MATVARNAME, stmt);
                    end
                   var_set{q,1} = 0; % indicate var is in mat
                else 
                    % verify this is just a reference
                    % check if this ID node is never on the right side when
                    % going up to its first parent EQUALS node.
                    if isVariableToSetValue(T.setIX(node_num))
                        % values of more than two variables are set on this line
                        % e.g., 'a=1; b=2;'
                        DAStudio.error('MATLAB:savevars:SaveVarsMultiVariablesSyntax', ...
                        line_no, m_filename, varname);
                    end
                end % if matvars
            end
        else % function node
            if strcmp(varname, MATVARNAME)
                DAStudio.error('MATLAB:savevars:SaveVarsMATLoadMissing', ...
                             line_no, m_filename, MATVARNAME, MATVARNAME);
            end
        end % if first id
        k = k+1; % go to next variable id
    else
        q = q+1; % var comes from the later statements 
        assert(q<=num_statements);
    end
end % while

if (hline>0 && matline>0)
    if(hline+HEADERHEIGHT ~= matline)
        DAStudio.error('MATLAB:savevars:SaveVarsLoadHeaderOff', ...
                        matline, m_filename, MATVARNAME);
    end
end
% set the ownership of tmpvars
for q = num_statements:-1:1;

    if ~isempty(var_set{q,1}) && strcmp(var_set{q,2}{1}, TMPVARNAME)
        if ( q < num_statements )
            var_set{q,1} = var_set{q+1,1};
            var_set{q,2}{1} = var_set{q+1,2}{1};
        else
            % last statement is tmpvars, set to empty
            var_set{q,1} = [];
            var_set{q,2}{1} = '';
        end
    end
end

% set variable code line range in struct s
use_tmpvar = false;
unclaimedFncClearlineno = 0;
varname = '';
for q = 1:num_statements

    type = var_set{q,1};
    start_line = R(q,1);
    end_line = R(q,2);
    tmpvarFlag = tmpvar_flags(q);
          
    if ~isempty(type) && type >= 0 
        % this is a variable, not a function
        varname = var_set{q,2}{1};
        
        if ~isfield(s, varname) 
            s.(varname) = [start_line, end_line, type, tmpvarFlag]; % first statement
            % assign the unclaimed clear('tempvars') to this statement
            if unclaimedFncClearlineno > 0
                s.(varname)(1) = unclaimedFncClearlineno;
                s.(varname)(4) = 1; % varname uses tmp variable
                unclaimedFncClearlineno = 0;
            end
        else 
            s.(varname)(2) = end_line; % update its MATLAB Code end range
            s.(varname)(3) = type; % update var in MATLAB Code or MAT
            if tmpvarFlag > 0
                s.(varname)(4) = 1; % varname uses tmp variable
            end
        end

    elseif ~isempty(type) && type == -2 
        % clear('tmpvars') statement
        if isempty(varname) || strcmp(varname, MATVARNAME)
            unclaimedFncClearlineno = start_line;
        else
            s.(varname)(2) = end_line; % update MATLAB Code range
            s.(varname)(4) = 1; % varname uses tmp variable
        end
    else
        % this statement(e.g., function) is not reported to saveVars
        if tmpvarFlag > 0
            use_tmpvar = true;
        end
    end
end


% check syntax clear('tmpvars'), or clear tmpvars
function flag = isFncClearSyntaxCorrect(this_node, tmpvarname)
flag = 0;
if ( this_node.Parent.isnull )
    flag = -1;
elseif ( ~this_node.Parent.Right.isnull )
    % have one variable to clear
    first_arg = this_node.Parent.Right;
    if ~first_arg.iskind('STRING')
        flag = -1;
    elseif strcmp(first_arg.string, tmpvarname) || strcmp(first_arg.string, ['''', tmpvarname, ''''])
        % clear tmpvars
        flag = 1;
        % should not have second var to clear
        second_arg = this_node.Parent.Right.Next;
        if ~second_arg.isnull
            flag = -1;
        end
    else
        flag = 0; % clear some other var 
    end
end
    
% verify the statement in this_node has correct syntax as in stmt
function flag = verifyMatvarStatement(this_node, stmt)
flag = false;
if ( this_node.isnull || this_node.Parent.isnull )
    return;
end
% filename has format fname.m
base = mtree(stmt);
if isequal(this_node.Parent.tree2str(0,true), base.tree2str(0,true))
    flag = true;
end

function flag = isMatvarSyntaxCorrect(this_node, stmt)

flag = false;
if this_node.isnull || this_node.Parent.isnull 
    return;
else
    eq_node = this_node.Parent.Parent;
    if eq_node.isnull || ~eq_node.iskind('EQUALS')
        return;
    end
end

if eq_node.Left.isnull || ~eq_node.Left.iskind('ID')
    return;
else
    flag = verifyMatvarStatement(eq_node, stmt);
end

% check if the variable is aasigned with value
function flag = isVariableToSetValue(this_node)
flag = true;
while( ~this_node.iskind('EQUALS') )
    if this_node.Parent.isnull || this_node.Parent.Right.eq(this_node)
        flag = false;
        break;
    else
        this_node = this_node.Parent;
    end
end

% check if any variable has interleaved statements
function checkCodeLineOverlappingAmongVariables(m_filename, s)
var_names = fieldnames(s);
num_vars = length(var_names);
checkList = true(num_vars,1);
for k=1:num_vars
    range_end = s.(var_names{k})(2);
    for m=k+1:num_vars
        if ( range_end < s.(var_names{m})(1) )
            break;
        else
            checkList(k) = false;
            if ( range_end <= s.(var_names{m})(2) )
                checkList(m) = false;
                break;
            end
        end
    end
end

% error out if any overlapping on MATLAB Code range is detected
if ~isequal(checkList, true(num_vars,1))
    bad_varnames = '';
    isfirst = true;
    for k=1:num_vars
        if ~checkList(k)
            lines = s.(var_names{k});
            if ( isfirst )
                bad_varnames = ['''', var_names{k},...
                    ''' [', num2str(lines(1)),'~',num2str(lines(2)),']'];
                isfirst = false;
            else
                bad_varnames = strcat(bad_varnames, [', ''', var_names{k},...
                    ''' [', num2str(lines(1)),'~',num2str(lines(2)),']']);
            end
        end
    end
% e.g., a(1) = 1; b(1) = 2; a(2) = 3; b(2) = 4;
DAStudio.error('MATLAB:savevars:SaveVarsOverlappedSyntax', ... 
        m_filename, bad_varnames);
end

% LocalWords:  linenos Tmp tmpvarinrest SAVEVARS SLsave MFile isvar codeline
% LocalWords:  lineno matvars DCALL BLKCOM Isfun func tmp Fnc tmpvars endline
% LocalWords:  tempvars varname stmt fname aasigned
