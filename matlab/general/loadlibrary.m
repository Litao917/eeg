function [notfound,warnings]=loadlibrary(library,header,varargin)
%LOADLIBRARY Load a shared library into MATLAB. 
%   LOADLIBRARY(SHRLIB,HDRFILE) Loads the functions defined in
%   header file HDRFILE and found in library SHRLIB into MATLAB.
%
%   LOADLIBRARY(SHRLIB,@PROTOFILE) Loads the functions defined in MATLAB
%   program file PROTOFILE  and found in library SHRLIB into MATLAB.
%   PROTOFILE  is a MATLAB program file that had previously been generated by
%   LOADLIBRARY using the 'MFILENAME' option.  @PROTOFILE  is a function
%   handle that references this file.
%
%   [NOTFOUND, WARNINGS] = LOADLIBRARY('SHRLIB','HDRFILE') returns warning
%   information from the shrlib library file. NOTFOUND is a cell array of
%   the names of functions found in the header file HDRFILE, or any header
%   added with the addheader option, but not found in the SHRLIB library.
%   WARNINGS contains a single character array of warnings produced while
%   processing the header file HDRFILE.
%
%   LOADLIBRARY(SHRLIB,...,OPTIONS) Loads the library SHRLIB with one
%   or more of the following OPTIONS.  (Only the ALIAS option is
%   available when loading using a prototype file.)
%
%   OPTIONS:
%      'ALIAS',LIBNAME     Allows the library to be loaded as a 
%          different library name.
%
%      'ADDHEADER',HDRFILE     Loads the functions defined in the 
%          additional header file, HDRFILE. Specify the header 
%          parameter as a filename without a file extension.  
%          MATLAB does not verify the existence of the header files 
%          and ignores any that are not needed.
%
%          You can specify as many additional header files as you need 
%          using the syntax
%             LOADLIBRARY shrlib hdrfile ...
%                addheader hdrfile1 ...
%                addheader hdrfile2 ...          % and so on
%
%      'INCLUDEPATH',PATHSPEC     Adds additional path in which to
%      look for included header files.
%
%      'MFILENAME',PROTOFILE    Creates the prototype program file PROTOFILE  
%          in the current directory and uses that file to load the library.  
%          Successive LOADLIBRARY commands can specify the function handle 
%          @PROTOFILE to use this prototype file as the header in loading
%          the library.  You can use this to speed up and simplify the 
%          load process.
%
%       'THUNKFILENAME',TFILENAME Overrides the default thunk file name
%       with TFILENAME.  See the DOC LOADLIBRARY section "Using loadlibrary
%       on 64-Bit Platforms" for more information.
%
%   This function requires a C compiler.  A compiler is not normally 
%   present on 64-bit Windows  and must be installed.  See DOC LOADLIBRARY
%   for a list of supported compilers.
%
%   See also UNLOADLIBRARY, LIBISLOADED, LIBFUNCTIONS.

%   Copyright 2002-2013 The MathWorks, Inc.


if (nargin == 0) 
    error(message('MATLAB:loadlibrary:NotEnoughInputs'));
end

createThunk=false;
needsthunk = false;
if isempty(regexp(computer,'^(PCWIN|GLNX86|MACI)$')) %#ok
    needsthunk = true;
end
SharedLibExt=system_dependent('GetSharedLibExt');
            
%init local variables
thunkfilename = '';
cleanupTempFiles=true;
usetempdir=true;
perlopt={};
parsemsg=[];
classname=[];
mfile_name=[];
protofunction=[];
ccinclude=[];
nocpp=false;
mode=1; %default modes: 1:perl 2:mpar 3:mfile 4:matfile
genMfile=false;
debug=false;
delfiles={};  %files added to this list will be deleted when done
workingDir = '';
cleanupDirOnUnload = '';
warnings='';
compilerConfiguration=[];
%process optional inputs
if nargin > 2
    i=1;
    while i<=length(varargin)
        str=varargin{i};
        if ~ischar(str)
            error (message('MATLAB:loadlibrary:OptionsMustBeStrings'));
        end
        switch (str)
            case 'notempdir'
                usetempdir=false;
                cleanupTempFiles=false;
                genMfile=true;
            case 'alias'
                i=i+1;
                classname=varargin{i};
            case 'nocpp' % do not use c pre processor
                nocpp=true;
            case 'mpar' % parse using mparc
                mode=2;
            case 'ppar' % parse using perl
                mode=1;
            case 'includepath'
                i=i+1;
                % LCC gets confused if an include dir ends in \ so remove
                % trailing \ with regexprep.
                ccinclude=[ccinclude ' -I' quoteFilename(regexprep(varargin{i},'[\\/]$',''))];    %#ok<*AGROW>
            case 'mfilename'
                i=i+1;
                mfile_name=varargin{i};
                usetempdir=false;
                genMfile=true;
            case 'addheader'
                i=i+1;
                perlopt{end+1}=varargin{i};
            case 'debug'
                if i<length(varargin)
                    i=i+1;
                    perlopt{end+1}=['-debug=' varargin{i}];
                else
                    perlopt{end+1}='-debug';
                end
                debug=true;
            case 'thunkfilename'
                usetempdir=false;
                i = i +1;
                thunkfilename=varargin{i};
                if ~isempty(thunkfilename)
                    createThunk = true;
                else
                    if needsthunk
                        warning(message('MATLAB:loadlibrary:thunkneeded'));
                        needsthunk=false;
                    end
                end
            case 'createThunk'
                createThunk = true;
            case 'compilerconfiguration'
                i=i+1;
                compilerConfiguration=varargin{i};
            otherwise 
                error(message('MATLAB:loadlibrary:InvalidOption', str)); 
        end
        i=i+1;
    end
end

try 
    librarypath=lFullPath(library,SharedLibExt);
catch exception
    %The system may still be able to find the library
    if ~strcmp(exception.identifier,'MATLAB:loadlibrary:FileNotFound')
        throw(exception);
    end
    librarypath=library;
end
[~,libname]=fileparts(librarypath); % dummy is not used

if isempty(classname)
    classname=genvarname(libname);
    if strcmp(classname,libname)~=1
        warning(message('MATLAB:loadlibrary:ClassRenamed', classname));
    elseif isempty(regexp(library,[libname '(\.[^.\\/]+)?$'], 'once' ))
        warning(message('MATLAB:loadlibrary:ClassCaseMismatch', classname));
    end
end

if libisloaded(classname)
    warning(message('MATLAB:loadlibrary:ClassIsLoaded', classname));
    if (nargout>=1)
        notfound=[];
    end
    return;
end

% Now figure out what the second input is and setup mode accordingly.
if nargin==1
    header=libname;
end

if isa(header,'function_handle')
    mode =3;
elseif ischar(header)
    [headerpath,headername,headerext]=fileparts(header);
    ftype=exist(header,'file');
    if ftype==0 || ftype==3 %need to determine what and where it is
        if isempty(headerext)
            header = strcat(header,'.h');
            headerext='.h';
        end
    end
    switch headerext
        case '.i'
            nocpp=true;
        case '.mat'
            mode=4;
            nocpp=true;
            usetempdir=false;
        case ''
            if strcmp(headername,header) && ~isempty(which(header))
                mode=3; %if the user passed in a MATLAB file name on
                % the path
            end
        otherwise
            %treat the input like a header file no action is needed            
    end
    if mode<3
        header=lFullPath(header);
        [headerpath,headername]=fileparts(header);
    end
else
    error(message('MATLAB:loadlibrary:InvalidSecondArgument'));
end

%set up for perl 
if (mode == 3 )
    nocpp=true;
    usetempdir=false;
    if (nargin>=2)
        if isa(header,'function_handle')
            protofunction=header;
        else
            protofunction=headername;
        end
    end             
elseif mode<=2
    if isdeployed
        error(message('MATLAB:loadlibrary:NoHeaderAllowed'));
    end
    if mode==1  %% do this here because cd later will prevent finding in private
        prototypes=which('prototypes.pl');
    end
    if needsthunk
        createThunk=true;
    end
    if (nocpp)
        preprocfile=header;
    else    
        preprocfile=[headername '.i'];
        delfiles{end+1}=preprocfile;        
    end
    [thunk_build_fn,preprocess_command]=getLoadlibraryCompilerConfiguration(ccinclude,header,headername,compilerConfiguration);
 end

if isempty(protofunction) && (mode==1 || mode ==3) 
    if isempty(mfile_name)  
        protofunction=genvarname([classname '_proto']);
        mfile_name=[protofunction '.m'];
        if ~genMfile 
            delfiles{end+1}= mfile_name;
        end
    else
        [~,fn]=fileparts(mfile_name); 
        mfile_name=[fn '.m'];
        protofunction=fn;
    end
end

if createThunk
    if isempty(thunkfilename)
        thunkfilename = [classname '_thunk_' lower(computer)];

    end
    pwdstr = pwd;
    if (~isempty(pwdstr) && pwdstr(end) == '\') %see g977138
        pwdstr = [pwdstr, '\'];
    end
    additional_thunk_includes = ['-I' quoteFilename(pwdstr)];
    if ~isempty(headerpath)
        additional_thunk_includes = [additional_thunk_includes ' -I' quoteFilename(headerpath)];
    end
    %use only full paths
    if regexp(thunkfilename,'^([a-zA-Z]:)?[\\/]')~=1
        thunkfilename = [pwd filesep thunkfilename];
    end

    thunkfilecname = [thunkfilename '.c'];
    delfiles{end+1}= thunkfilecname;
end

%for notempdir and mode 2 (mpar)
if genMfile && isempty(mfile_name)
    protofunction=genvarname([classname '_proto']);
    mfile_name=[protofunction '.m'];
end

if ~isa(protofunction,'function_handle') && exist(protofunction,'file')==3 && strcmpi(protofunction,libname)
    error(message('MATLAB:loadlibrary:invalid_mfilename'));
end

savedir=pwd;
restoreOriginalPwd=onCleanup(@() cd(savedir));
try
    stage='Preprocess';
    if usetempdir
        workingDir = tempname;
        mkdir(workingDir);
        cd (workingDir);
    else
        workingDir='';
    end
    if (~nocpp)
        [res,ccout]=system(preprocess_command);
        if (res~=0)
            error(message('MATLAB:loadlibrary:cppfailure', ccout));
        end
        % The LCC preprocessor which is not internationalized does not
        % properly return an error status.
        if (res==0 && ~isempty(regexpi(ccout,'\<(warning|error)\>','once')) )
            warning(message('MATLAB:loadlibrary:cppoutput', ccout));
        end
        warnings=[warnings,ccout];
    end

    if mode==1
        clear(protofunction);
        % Use perl to generate the program file.  The file should be the
        % same regardless of if we are using a precompiled thunk or not.
        % Note that the matlab perl command will double quote all arguments
        % that contain one or more spaces.  Do not pre-quote file names
        % with spaces.
        if createThunk
            [parsemsg, status] = perl(prototypes, preprocfile, ['-outfile=' mfile_name],...
                ['-thunkfile=' thunkfilecname],['-header=' headername headerext], perlopt{:});
        else
            [parsemsg,status]=perl(prototypes , preprocfile,['-outfile=' mfile_name],...
                perlopt{:});
        end
        warnings=[warnings parsemsg];
        if status<0 || status >1
            error(message('MATLAB:loadlibrary:cannotgeneratemfile',parsemsg));
        elseif nargout < 2
            if debug 
                disp(parsemsg);
            elseif status==1 
            warning(message('MATLAB:loadlibrary:parsewarnings'));
            end
        end
        loop=1;
        fschange(pwd);
        while (exist(mfile_name,'file')~=2)
            if (loop>256)
                error(message('MATLAB:loadlibrary:PrototypeFileNotFound'));
            end
            pause(loop*0.01);
            fschange(pwd);
            loop=loop*2;
        end;
        clear loop;
    end
    
    if createThunk
        if isempty(thunkfilename)
            error(message('MATLAB:loadlibrary:EmptyThunkfileNames'));
        end
        [status,results]=thunk_build_fn(additional_thunk_includes,thunkfilecname,addfileext(thunkfilename, SharedLibExt));
        warnings=[warnings results];
        if (status~=0)
            error(message('MATLAB:loadlibrary:CompileFailed', thunkfilename, results));
        end
        cleanupDirOnUnload = workingDir;
    end
    
    if mode==1 || mode == 3     % protofunction is provided by function handle
       stage='RunFn';
       try
           [fcns,structs,enums,thunkfilename]=feval(protofunction);
       catch err
           if strcmp(err.identifier,'MATLAB:TooManyOutputs')
               warning(message('MATLAB:loadlibrary:OldStyleMfile'));
               [fcns,structs,enums]=feval(protofunction);
           else
               err.rethrow;
           end
       end
    elseif mode==2
       stage='mparc';
       [fcns,structs,enums]=mparc(preprocfile);
       % Write the program file out here if needed.
       if genMfile
           mcheaderexternal(fcns,structs,enums,mfile_name);
       end
    else % mode better be 4
        % Not yet tested and fully implemented.
        load(header);
    end
    
    stage='LoadDefined';
    if ~isempty(thunkfilename)
        thunkfilename=addfileext(thunkfilename,SharedLibExt);
    end
    
    delete(restoreOriginalPwd); % cd back out of temp dir to avoid customer surprise about dll pwd and give customer more control

    loaddefinedlibrary(librarypath,fcns,classname,structs,enums, thunkfilename, cleanupDirOnUnload);
        
    deltempfiles(delfiles, cleanupTempFiles, workingDir, ~createThunk && usetempdir);

    if (nargout>=1)
        loaded=methods(['lib.' classname]);
        if (isempty(loaded) )
            warning(message('MATLAB:loadlibrary:nofunctions'));
            notfound=fcns.name;
        else
            notfound=setdiff(fcns.name,loaded,'legacy');
        end
    end
catch exception
    clear restoreOriginalPwd; 
    deltempfiles(delfiles, cleanupTempFiles, workingDir, usetempdir);
    throw(diagnoseError(exception,stage,mode));
end

    function err=diagnoseError(err,stage,mode)
    % This function uses stage and last error in conjunction with current
    % state to diagnose the error and print out helpful information
        loaderError=false;
        switch (stage)
            case 'RunFn'
                loaderError=true;
            case 'LoadDefined'
            otherwise
        end
        if ~any(strcmp(err.identifier,...
                {'MATLAB:UndefinedFunction','MATLAB:loadlibrary:LoadFailed'})) || debug
            if ~isempty(parsemsg)
                disp(getString(message('MATLAB:loadlibrary:IntermediateOutputFollows')))
                disp(getString(message('MATLAB:loadlibrary:ActualErrorAtEndOfOutput')));
                fprintf('*********\n%s*********\n',parsemsg);
            end
            if loaderError  
                if (length(err.stack)>1)
                    location=err.stack(1);
                else
                    location=regexp(err.message,...
                        'Line:\s+(?<line>\d+)\s+Column:\s+(?<column>\d+)','names');
                    if numel(location) >= 1
                        location.line=str2double(location.line);
                        location.file=mfile_name;
                        if isa(protofunction,'function_handle');
                            location.name=func2str(protofunction);
                        else
                            location.name=protofunction;
                        end
                    end
                end
                                   
                if mode>2 && ~isempty(location)
                    new_err = MException(err.identifier,'%s\n%s\n', getString(message('MATLAB:loadlibrary:ErrorInHeader',err.message,location.name,location.line)),getString(message('MATLAB:loadlibrary:ErrorRunningFromCommandLine',...
                        location.file,location.name)));
                else
                    new_err = MException(err.identifier, '\n%s',getString(message('MATLAB:loadlibrary:ErrorRunningLoaderFile')));
                end
                new_err=addCause(new_err,err);
                new_err.throwAsCaller;
            end
        else
            new_err = MException(err.identifier, '%s',getString(message('MATLAB:loadlibrary:ErrorLoadingLibrary', librarypath,err.message)));
            new_err=addCause(new_err,err);
            new_err.throwAsCaller;
        end
        if (~isempty(regexp(err.identifier,':loadlibrary:','once')))
            throwAsCaller(err);
        else
            rethrow(err);
        end
        
    end %nested function diagnoseError
end % function loadlibrary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Helper Functions  %%%%%%%%%%%%%%%%%%%
function fixed=fixesc(input)
   fixed=strrep(input,'\','\\');
   fixed=strrep(fixed,'%','%%');
end

function [thunk_build_fn,preprocess_command]=getLoadlibraryCompilerConfiguration(ccinclude,header,headername,compilerConfiguration)

    thunk_build=[];
    thunk_build_fn=[];
    if isempty(compilerConfiguration)
        try
            compilerConfiguration=mex.getCompilerConfigurations('C','Selected');
        catch e
            throwAsCaller(e)
        end
        compilerConfiguration=compilerConfiguration(1);  %unix machines return c and cpp compilers here
    end
    Details=compilerConfiguration.Details;
    cc=Details.CompilerExecutable;
    build_opt=fixesc(Details.CompilerFlags);
    if ispc
        SystemDetails=Details.SystemDetails;
        restorematlab=protectEnvAddition('matlab',matlabroot); %#ok<NASGU> return value is an onCleanup object
        restorepath=protectEnvAddition('path',SystemDetails.SystemPath); %#ok<NASGU> 
        restoreinclude=protectEnvAddition('include',SystemDetails.IncludePath); %#ok<NASGU> 
        restorelib=protectEnvAddition('lib',SystemDetails.LibraryPath); %#ok<NASGU> 
    end
    ccinclude=[ccinclude ' -I' quoteFilename(fullfile(matlabroot, 'extern','include'))];

    switch (compilerConfiguration.Manufacturer)
        case {'Microsoft','Intel'}
            %-MD causes dll to be dependent on libraries that may not be installed?
            build_opt=regexprep(build_opt,'\<[\-/](c|MD|GR|EHs|DMATLAB_MEX_FILE)\>',''); % remove unneeded compiler options
            thunk_build=[fixesc(cc) fixesc(ccinclude) ' '  build_opt ' %s "%s" -LD -Fe"%s"'];
            preprocess_command=[cc ccinclude ' ' build_opt ' -E "' header '" > "' headername '.i"'];
            if strcmp(compilerConfiguration.Manufacturer,'Microsoft') && strcmp(compilerConfiguration.Version , '6.0') 
                 thunk_build_fn=@(varargin) noThunkingError('MATLAB:loadlibrary:ThunkfileNotSupportedbyMSVC6','The Microsoft Visual C 6.0 compiler cannot be used to build a thunk file.');
            end
        case 'LCC'
            build_opt=regexprep(build_opt,'\<[\-/](c|DMATLAB_MEX_FILE)\>',''); % remove unneeded compiler options
            %thunk_build=[fixesc(cc) fixesc(ccinclude) ' '  fixesc(build_opt) ' %s "%s" -Fo"%s"'];
            thunk_build_fn=@(varargin) noThunkingError('MATLAB:loadlibrary:ThunkfileNotSupportedbyLCC','The LCC compiler cannot be used to build a thunk file.');
            build_opt = strrep(build_opt, '%%MATLAB%%', '%MATLAB%');
            preprocess_command =[cc ' ' build_opt ccinclude ' -E ' quoteFilename(header) ];
        case 'Sybase' %Open Watcom
            build_opt=regexprep(build_opt,'\<[\-/](c|DMATLAB_MEX_FILE)\>',''); % remove unneeded compiler options
            preprocess_command=[cc ccinclude ' '  build_opt ' -pl "' header '" > "' headername '.i"'];
            thunk_build=[fixesc(cc) fixesc(ccinclude) ' '  build_opt ' %s "%s" %s']; %last %s is unused
            thunk_build_fn=@watcomThunkBuilder;
        case 'GNU'
            build_opt=regexprep(build_opt,'\<-ansi\>',''); 
            thunk_build=[cc ccinclude ' '  fixesc(build_opt) ' %s "%s" -o "%s" -Wl,-E -shared ']; %Linux
            preprocess_command=[cc ccinclude ' '  build_opt ' -x c -E "' header '" > "' headername '.i"'];
        case 'Apple'
            a = regexp(build_opt,'-isysroot\s+\$MW_SDKROOT');
            if (~isempty(a))
                content = fileread(compilerConfiguration.MexOpt);
                [~,~,~,~,~,tmpval] = regexp(content,'MW_SDKROOT=`(?<Name>[^"]+)`');
				if (strcmp(tmpval.Name, '$MW_SDKROOT_TMP'))
					[~,~,~,~,~,val] = regexp(content,'MW_SDKROOT_TMP="(?<Name>[^"]+)"');
					[status, out]=system(val.Name);
					if (status == 0)
						if (strcmp(out(end), char(10)))
							out = out(1:end-1);
						end
						build_opt = strrep(build_opt, '$MW_SDKROOT', out);
					end
				end
            end
            build_opt=regexprep(build_opt,{'$ARCHS','\-[\w\-]+[\s=]+\$\w+'}, {'x86_64',''}); % remove system variables
            thunk_build=[cc ccinclude ' '  fixesc(build_opt) ' %s "%s" -o "%s" -bundle '];
            preprocess_command=[cc ccinclude ' '  build_opt ' -x c -E "' header '" > "' headername '.i"'];
        otherwise
            error(message('MATLAB:loadlibrary:UnsupportedCompiler'));
    end
    if isempty(thunk_build_fn)
        thunk_build_fn=@thunkBuilder; %@(additional_thunk_includes,thunkfilecname,thunklibname) system(sprintf(thunk_build,additional_thunk_includes,thunkfilecname,thunklibname));
    end
    function [status,output]=thunkBuilder(additional_thunk_includes,thunkfilecname,thunklibname)
        cmd=sprintf(thunk_build,additional_thunk_includes,thunkfilecname,thunklibname);
        [status,output]=system(cmd);
        if status~=0
            output=sprintf('%s\n%s',cmd,output);
        end
    end
    function [status,output]=watcomThunkBuilder(additional_thunk_includes,thunkfilecname,thunklibname)
        [status,output]=thunkBuilder(additional_thunk_includes,thunkfilecname,'');
        if status==0
            thunkexe=regexprep(thunkfilecname,'\.c$','.exe');
            movefile(thunkexe,thunklibname);
        end
    end
end

function [foo,bar]=noThunkingError(id,msg) %#ok<STOUT>	 
     e=MException(id,msg);	 
     throwAsCaller(e);	 
end
 
function restore=protectEnvAddition(var,add)
if isempty(add)
    restore=[];
else
    oldvalue=getenv(var);
    restore=onCleanup(@()setenv(var,oldvalue));
    new= regexprep(add,'%(\w+)%','${getenv($1)}');  %replace %envname% with its value
    setenv(var,new);
end
end

function filepath=lFullPath(srcfile,ext)
% Find the full path to a file that is on the path, but is not a MATLAB
% program file.
filepath=which(srcfile);  %
if isempty(filepath) && nargin==2
    filepath=lFullPath(addfileext(srcfile,ext));
elseif isempty(filepath) || (exist(filepath,'file')==2 &&  strcmpi(filepath(end-1:end),'.m'))
    % The next code is for relative paths.
    if ~isempty(dir(fullfile(pwd,srcfile)))
        srcfile=fullfile(pwd,srcfile);
    end
    if isempty(dir(srcfile))
        error(message('MATLAB:loadlibrary:FileNotFound', srcfile));
    end
    filepath=srcfile;
end
end % function lFullPath

function fname=addfileext(fname,ext)
% Add a file extension if one does not exist in fname.
ind = regexp(fname,'\.[^.\\/]*$'); %#ok<RGXP1>
if isempty(ind)
    fname=[fname  ext];
end
end

function filename=quoteFilename(filename)
    filename=[ '"' filename '"'];
end % function quoteFilename

function deltempfiles(tempfiles, cleanup, tempdir, removeTempDir)
if cleanup
    for i=tempfiles
        if isempty(fileparts(i{1})) %if no path in file name
            fname=fullfile(tempdir,i{1});
        else
            fname=i{1};
        end
        if exist(fname,'file')
            delete(fname);
        end
    end
    if removeTempDir
        try
            rmdir(tempdir,'s'); % When successful this is done by unloadlibrary
        catch e 
            dirNotRemovedExpToIgnore = {'MATLAB:RMDIR:NoDirectoriesRemoved', 'MATLAB:RMDIR:SomeDirectoriesNotRemoved'};
            if( ~any( strcmp( dirNotRemovedExpToIgnore, e.identifier ) ) )
                rethrow(e); 
            end
        end 
    end
end
end % function deltempfiles

